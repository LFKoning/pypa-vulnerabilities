"""Module for parsing the PyPA vulnerabilities repositiory."""

import logging
import pathlib

import yaml

from vulnerabilities import Vulnerabilities


class VulnerbilityParser:
    """Class for parsing vulnerability YAML data."""

    REPO_URL = "https://github.com/pypa/advisory-database"

    def __init__(self, repo_path: str) -> None:
        self._log = logging.getLogger(self.__class__.__name__)
        self._repo_path = repo_path
        self._vulnerabilities = Vulnerabilities()

    def run(self):
        """Find and parse vulnerability YAML files."""
        repo = pathlib.Path(self._repo_path)
        yaml_paths = repo.rglob("*.yaml")

        if not yaml_paths:
            msg = f"No YAML vulnerability files found in: {self._repo_path}"
            self._log.error(msg)
            raise RuntimeError(msg)

        for yaml_path in yaml_paths:
            self._log.info("Processing: %s", yaml_path)
            with open(yaml_path, "r", encoding="utf8") as yaml_file:
                vulnerability = yaml.safe_load(yaml_file)

            # Extract affected packages from the vulnerability.
            extracted = self._extract_packages(vulnerability, yaml_path)
            if extracted == 0:
                self._log.warning("No packages found in vulnerability: %s", yaml_path)
            else:
                self._log.debug(
                    "Extracted %d packages from vulnerability %s.", extracted, yaml_path
                )

    def make_constraints(self, exact: list) -> str:
        """Create contents for a constraints file."""
        constraints = (
            "# Constraints automatically generated from PyPA advisory database.\n"
            f"# See: {self.REPO_URL}\n\n"
        )

        for package in self._vulnerabilities:
            if package in exact:
                versions, identifiers, source = (
                    self._vulnerabilities.get_vulnerable_versions(package)
                )

                constraints += f"# Based on: {', '.join(identifiers)}\n"
                constraints += f"# Source: {self.REPO_URL}/{source}\n"
                for version in versions:
                    constraints += f"{package} != {version}\n"

            else:

                fix, identifier, source = self._vulnerabilities.get_highest_fix(package)

                if fix:
                    # Allow fixed versions.
                    constraints += f"# Based on: {identifier}\n"
                    constraints += (
                        f"# Source: {self.REPO_URL}/{source[0]}/{source[1]}\n"
                    )
                    constraints += f"{package} >= {fix}\n"

                else:
                    # No fixed version, ban altogether.
                    constraints += f"# No safe versions exist for {package}!\n"
                    constraints += f"# See: {self.REPO_URL}/{package}\n"
                    constraints += f"{package} < 0.0.0\n"

            # Add newline for readability.
            constraints += "\n"

        return constraints

    def _extract_packages(self, vulnerability: dict, yaml_path: str) -> int:
        """Get all packages from a vulnerability."""
        extracted = 0
        for item in vulnerability["affected"]:
            if "package" in item:
                # Extract package name or skip.
                try:
                    package_name = item["package"]["name"]
                except KeyError:
                    self._log.warning("Cannot extract package name in: %s", yaml_path)
                    continue

                # Extract fixes.
                fixes = []
                for rng in item.get("ranges", []):
                    if rng["type"] == "ECOSYSTEM":
                        for event in rng.get("events", []):
                            if "fixed" in event:
                                fixes.append(event["fixed"])

                # Store package versions and fixes and some metadata.
                self._vulnerabilities.add(
                    package=package_name,
                    identifier=vulnerability["id"],
                    source=yaml_path,
                    versions=item.get("versions", []),
                    fixes=fixes,
                )
                extracted += 1

        return extracted
